/********************************************************************
 *                                                                  *
 *  file: svt_matrix.h                                              *
 *                                                                  *
 *  specification for class: svt_matrix                             *
 *  (pure inline template class)                                    *
 *                                                                  *
 *  f.delonge                                                       *
 *                                                                  *
 ********************************************************************/

#ifndef SVT_MATRIX_H
#define SVT_MATRIX_H

#include <svt_basics.h>
#include <float.h>
#include <svt_iostream.h>
#include <svt_exception.h>
#include <svt_streamableObject.h>
#include <svt_types.h>
#include <svt_bfstream.h>
#include <svt_cmath.h>
#include <svt_stlVector.h>


/** An abstract matrix base class as template.
	defines a lot of usfil operators, such as +,-,*,...
	\author Frank Delonge
*/


template<class T>
class DLLEXPORT svt_matrix : public svt_streamableObject
{
  public:
  
  enum ResizeMode {Uninitialized, 
				   Clear, 
				   Save, 
				   SaveClamp, 
				   SaveCenter, 
				   SaveCenterClamp, 
				   Interpolate}; 

  // All operators are now based on public methods because of
  // trouble with some compilers at friend decalaration.
  // Therefore, the matrix class does not have any friends, but
  // operators shall be documented that way.
  // (Therewith, these operators appear in the svt_matrix class documentation
  //  generated by doxygen).
  
#ifdef DOXYGEN

  /** Compare 2 matrixes.
   */
  friend bool operator==<T> (const svt_matrix<T>& A, const svt_matrix<T>& B);  
  
  /** Same as !(A==B).
   */
  friend bool operator!=<T> (const svt_matrix<T>& A, const svt_matrix<T>& B);  
  

  /** Add 2 matrixes elementwise.
 	  @exception svt_exception if sizes are not conform
  */
  friend svt_matrix<T> operator+<T> (const svt_matrix<T>& A, const svt_matrix<T>& B);  
  
  /** Add matrix and scalar -> matrix.
 	  Value is added to each element of A.
  */
  friend svt_matrix<T> operator+<T> (const svt_matrix<T>& A, const T& value);  
  
  
  /** Add scalar and matrix -> matrix.
 	  value is added to each element of A
  */
  friend svt_matrix<T> operator+<T> (const T& value, const svt_matrix<T>& B);  
  
  /** substract 2 matrixes elementwise
 	  @exception svt_exception if sizes are not conform
  */
  friend svt_matrix<T> operator-<T> (const svt_matrix<T>& A, const svt_matrix<T>& B);  
  
  

  /** Subtract matrix a scalar from matrix A -> matrix.
 	  Value is substracted from each element of A.
  */
  friend svt_matrix<T> operator-<T> (const svt_matrix<T>& A, const T& value);  
  
  /** Subtract scalar and matrix -> matrix.
 	  Same as -(A-value).
  */
  friend svt_matrix<T> operator-<T> (const T& value, const svt_matrix<T>& B);  
  
  
  
  /** Negates each element.
 	  Same as 0-A.
  */
  friend svt_matrix<T> operator-<T> (const svt_matrix<T>& A);  
  
  /** Matrix multiplication. 
 	  A(h1,b1)*B(h2,b2) -> matrix(h1, b2)
 	  @exception svt_exception if sizes are not conform (means here: b1!=b2)
  */
  friend svt_matrix<T> operator*<T> (const svt_matrix<T>& A, const svt_matrix<T>& B);  
  
  /// scalar multiplication (elementwise)
  friend svt_matrix<T> operator*<T> (const svt_matrix<T>& A, const T& value);  
  
  /// scalar multiplication (elementwise)
  friend svt_matrix<T> operator*<T> (const T& value, const svt_matrix<T>& A);  
  
  /// same as A*(1/value)
  friend svt_matrix<T> operator/<T> (const svt_matrix<T>& A, const T& value);  
  
  ///compaires
 // friend svt_matrix<T> operator<<T> (const svt_matrix<T>& A, const svt_matrix<T>& B);  
  
  /// get the maximum value of A
  friend T max<T> (const svt_matrix<T>& A);
  
  /// get the minimum value of A
  friend T min<T> (const svt_matrix<T>& A);
  
#endif


  //////////////////////////////////////////////////////////////////////
  //                                                                  //
  //                P U B L I C   M E T H O D S                       //
  //                                                                  //
  //////////////////////////////////////////////////////////////////////

  public:
  

  //
  // constructors
  //

  /** Create a matrix A sized iHeight x iWidth.
	  If args are omitted, an empty matrix is created
	  values are uninitialized.
  */
  svt_matrix(unsigned iHeight=0, unsigned iWidth=0);

  /** create a matrix A sized iHeight x iWidth with default values initialValue
	  same as svt_matrix A(h,w); A=initialValue;
  */
  svt_matrix(unsigned iHeight, unsigned iWidth, const T& initialValue);

  /**
   * copy-constructor, e.g. svt_matrix B(A);
   */
  svt_matrix(const svt_matrix& that);


  /// destructor
  virtual ~svt_matrix();


  //
  // assign operators
  //


  /** assign a scalar value, e.g. A=1.
   * The size of A will be unchanged, value is assigned to all elements.
   */
  svt_matrix<T>& operator=(const T& value);

  /** Assign a matrix B to a matrix A, e.g. A=B.
	  Size and values will become same as B.
  */
  svt_matrix<T>& operator=(const svt_matrix<T>& that);


  //
  // dereference operators
  //

  /** dereference a matrix A: A[row][column] (unchecked).
      (the second [] is evaluated by c itself.)
  */
  T* operator[](unsigned iRow);

  /** dereference a constant matrix A: A[row][column] (unchecked).
	  (the second [] is evaluated by c itself.)
	  In this case, the expression is not an l-value! 
  */
  const T* operator[](unsigned iRow) const;

  /// dereference a matrix A: A[row][column] (range-checked)
  T& at(unsigned iRow, unsigned iColumn);

  /** Dereference a constant matrix A: A[row][column] (range-checked).
	  In this case, the expression is not an l-value! 
  */
  const T& at(unsigned iRow, unsigned iColumn) const;

  // 
  // modification operators
  //

  /// performs a ++ on each element (prefix) 
   svt_matrix<T>&  operator++();
 
  /// performs a ++ on each element (postfix)
  svt_matrix<T>&  operator++(int);


  /// adds value to each element
  svt_matrix<T>& operator+=(const T& value);

  /** Adds the matrix B.
	 if matrixes are not size-conform, exception is thrown
  */
  svt_matrix<T>& operator+=(const svt_matrix<T>& B);

  /// performs a -- on each element (prefix)
  svt_matrix<T>& operator--();

  /// performs a -- on each element (postfix)
  svt_matrix<T>& operator--(int);

  /// substracts value from each element
  svt_matrix<T>& operator-=(const T& value);

  /** substracts the matrix B.
	  \throw svt_exception, if matrixes are not size-conform.
  */
  svt_matrix<T>& operator-=(const svt_matrix<T>& B);

  /// scalar multiplication with value
  svt_matrix<T>& operator*=(const T& value);

  /** matrix multiplication.
	  \throw svt_exception, if matrixes are not size-conform.
  */
  svt_matrix<T>& operator*=(const svt_matrix<T>& B);

  /// same as A*=(1/value)
  svt_matrix<T>& operator/=(const T& value);

  /**
   * nxn matrix inversion by Gauss-Jordan elimination
   */
  void gaussjordan();
  
  /**
   * Filles the matrix with the values of the argument matrix. It places them as a block
   * \param oSrc provides the values to copy
   * \param iRow the row position where the top right cornet of oSrc will be placed
   * \param iCol the column position where the top right cornet of oSrc will be placed
   */
  void fill(svt_matrix<T> &oSrc, unsigned int iRow, unsigned int iCol);


  /**
   * min/max
   */
  //@{
  T min() const;
  T max() const;
  T minOnRow(unsigned int iIndexRow) const;
  T maxOnRow(unsigned int iIndexRow) const;
  T nthMaxOnRow(unsigned int iIndexRow, unsigned int iIndex) const;
  //@}
  //
  // query size
  //

  /// get amount of columns
  unsigned width() const;

  /// get amount of rows
  unsigned height() const;

  //
  // modify size
  //


  /** Resize to new dimensions.
   * The Parameter eResizeMode steers handling of former content: <br>
   *   Uninitialized   - The new content does not get initialized at all (default).<br>
   *   Clear           - The new content is initialized with the value tClearValue. <br>
   *   Save            - The former content will get copied into the new matrix, alway starting at the top left corner.
   *                     If the new size is greater than the old one, all new entries become tInitialValue. <br>
   *   SaveClamp       - Same as above, but new values are copies of the last old value in their row or column. <br>
   *   SaveCenter      - The old content is centered in the new matrix, new values at the borders become tInitialValue. <br> 
   *   SaveCenterClamp - Same as above, but border values are clamped to first inner old value. <br>
   *   Interpolate     - Bilinear Interpolation to new dimensions. <br>  
   *
   * If old size == new size, nothing happens no matter which other arguments are specified.
   * If the matrix is of fixed size (and thus uses stack memory), attempting
   * to resize the matrix will yield an exception.
   */


  void resize( unsigned iHeight, unsigned iWidth, ResizeMode eResizeMode=Uninitialized, const T& tClearValue = T(0));

  /** get data as c-type vector.
   */
  T* c_data() const;



  //////////////////////////////////////////////////////////////////////
  //                                                                  //
  //             P R O T E C T E D   S T U F F                        //
  //                                                                  //
  //////////////////////////////////////////////////////////////////////

protected:

  /** Constructor to pass in memory pointer.
   *  This constructor can be used by inherited classes
   *  that use fix stack memory.
  */
  svt_matrix(unsigned iHeight, unsigned iWidth, T* data);

  /** create a matrix A sized iHeight x iWidth with default values initialValue
	  same as svt_matrix A(h,w); A=initialValue;
  */
  svt_matrix(unsigned iHeight, unsigned iWidth, const T& initialValue, T* data);

  /**
   * copy-constructor, e.g. svt_matrix B(A);
   */
  svt_matrix(const svt_matrix& that, T* data);


  // 
  // stream operators
  //

  /// virtual stream methods used by operators << and >>
  virtual void streamOutA(ostream& s) const;
  virtual void streamInA(istream& s);



  /// binary i/o methods
  virtual void streamOutB(svt_obfstream& s) const;
  virtual void streamInB(svt_ibfstream& s);


  /// amount of columns
  unsigned m_iWidth;

  /// amount of rows
  unsigned m_iHeight;  

  /// data
  T* m_pData;
  

private:

  /// init method used by contructors
  void init(unsigned iHeight, unsigned iWidth);  
  bool m_bUsesDynMem;

};

/////////////////////////////////////////////////////////////////////////////




  //////////////////////////////////////////////////////////////////////
  //                                                                  //
  //             I N L I N E   D E F I N I T I O N S                  //
  //                                                                  //
  //////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////
// init methods used by construcots                           (private)  //
//   void svt_matrx::init()                                              //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline void svt_matrix<T>::init(unsigned iHeight, unsigned iWidth)
{
  if (m_bUsesDynMem)
	{
	if ( iWidth*iHeight != 0) 
	  {
	  m_iWidth = iWidth;
	  m_iHeight = iHeight;
	  m_pData = new T[m_iHeight*m_iWidth];
	  }
	else
	  {
	  m_iWidth = 0;
	  m_iHeight = 0;
	  m_pData = NULL;	
	  }
	}
  return;
}



///////////////////////////////////////////////////////////////////////////
//   Public Constructors                                                 //
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
// Class Constructor:                                                    //
//   svt_matrix::svt_matrix(unsigned, unsigned)                          //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::svt_matrix(unsigned iHeight, unsigned iWidth) 
  : m_bUsesDynMem(true)
{
  init(iHeight, iWidth);
  return;
}


///////////////////////////////////////////////////////////////////////////
// Class Constructor:                                                    //
//   svt_matrix::svt_matrix(unsigned, unsigned, T)                       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::svt_matrix(unsigned iHeight, unsigned iWidth, const T& initialValue)
  : m_bUsesDynMem(true)
{
  init(iHeight, iWidth); 

  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]=initialValue;

}


///////////////////////////////////////////////////////////////////////////
// Class Copy Constructor:                                               //
//   svt_matrix::svt_matrix(const svt_matrix&)                           //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::svt_matrix(const svt_matrix& that)
  : svt_streamableObject(), m_iWidth(that.m_iWidth), m_iHeight(that.m_iHeight),
	m_bUsesDynMem(true)
{
  if (m_iHeight*m_iWidth != 0)
	{
	m_pData = new T[m_iHeight*m_iWidth];
	memcpy(m_pData, that.m_pData,m_iHeight*m_iWidth*sizeof(T) );	
	}
  else
	m_pData=NULL;

}

///////////////////////////////////////////////////////////////////////////
//   Protected Constructors                                              //
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
// Class Constructor:                                                    //
//   svt_matrix::svt_matrix(unsigned, unsigned)                          //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::svt_matrix(unsigned iHeight, unsigned iWidth, T* data) 
    : m_iWidth(iWidth), m_iHeight(iHeight), m_pData(data), m_bUsesDynMem(false)
{}


///////////////////////////////////////////////////////////////////////////
// Class Constructor:                                                    //
//   svt_matrix::svt_matrix(unsigned, unsigned, T)                       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::svt_matrix(unsigned iHeight, unsigned iWidth, const T& initialValue, T* data)
  : m_iWidth(iWidth), m_iHeight(iHeight), m_pData(data), m_bUsesDynMem(false)
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]=initialValue;
}


///////////////////////////////////////////////////////////////////////////
// Class Copy Constructor:                                               //
//   svt_matrix::svt_matrix(const svt_matrix&)                           //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::svt_matrix(const svt_matrix& that, T* data)
: svt_streamableObject(), m_iWidth(that.m_iWidth), m_iHeight(that.m_iHeight),
  m_pData(data), m_bUsesDynMem(false)
{
    memcpy(m_pData, that.m_pData,m_iHeight*m_iWidth*sizeof(T) );
}


///////////////////////////////////////////////////////////////////////////
// Class Destructor:                                      (virtual)      //
//   svt_matrix::~svt_matrix()                                           //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>::~svt_matrix()
{
    if (m_pData && m_bUsesDynMem)
	delete[] m_pData;
}
  

///////////////////////////////////////////////////////////////////////////
// Assign Operator                                                       //
//    svt_matrix::operator=(const T& value)                              //
// assign value to each element                                          //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator=(const T& value)
{

  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]=value;

  return *this;

}


///////////////////////////////////////////////////////////////////////////
// Assign Operator                                                       //
//    svt_matrix::operator=(const svt_matrix<T>& that)                   //
// assign that to this                                                   //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator=(const svt_matrix<T>& that)
{
  //
  // self-test
  //
  if (this == &that)
	return *this;

  //
  // resize to shape of that
  // (this may throw an exception...)
  //
  resize(that.height(), that.width());

  // 
  // copy that's data 
  //
  memcpy(m_pData, that.m_pData, m_iHeight*m_iWidth*sizeof(T));
  return *this;

}


///////////////////////////////////////////////////////////////////////////
// range-unchecked Dereference Operator                                  //
//    svt_matrix::operator[](unsigned iRow)                              //
// intented to be used as matrix[iRow][iColumn]                          //
// this method returns a pointer to the first element of the iRow´th Row //
// the second [] is done by c                                            //
// range-unchecked                                                       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline T* svt_matrix<T>::operator[](unsigned iRow)
{
  return &(m_pData[iRow*m_iWidth]);
}


///////////////////////////////////////////////////////////////////////////
// range-unchecked Dereference Operator                                  //
//    svt_matrix::operator[](unsigned iRow) const                        //
// intented to be used as matrix[iRow][iColumn]                          //
// same as above, but for const matrixes                                 //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline const T* svt_matrix<T>::operator[](unsigned iRow) const
{
  return &(m_pData[iRow*m_iWidth]);
}


///////////////////////////////////////////////////////////////////////////
// range-checked element access method                                   //
//    svt_matrix::at(unsigned iRow, unsigned iColumn)                    //
// thows svt_exception if iRow or iColumn is out of range                //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline T& svt_matrix<T>::at(unsigned iRow, unsigned iCol)
{
  if (iRow >= m_iHeight || iCol >= m_iWidth )
	throw svt_exception( "svt_matrix:: at():size ot of range!");
  return (*this)[iRow][iCol];

}


///////////////////////////////////////////////////////////////////////////
// range-checked element access method for constant matrixes             //
//    svt_matrix::at(unsigned iRow, unsigned iColumn)                    //
// thows svt_exception if iRow or iColumn is out of range                //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline const T& svt_matrix<T>::at(unsigned iRow, unsigned iCol) const
{
  if (iRow >= m_iHeight || iCol >= m_iWidth )
	throw svt_exception("svt_matrix:: at():size ot of range!");
  return (*this)[iRow][iCol];
}


///////////////////////////////////////////////////////////////////////////
// prefix ++ operator: performs ++ on each element                       //
//    svt_matrix::operator++                                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator++() 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	++m_pData[i];

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// postfix ++ operator: performs ++ on each element                      //
//    svt_matrix::operator++                                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator++(int) 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]++;

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// += operator for scalar values                                         // 
//    svt_matrix::operator+= (const T& value)                            //
// adds value to each matrix element                                     //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator+=(const T& value)
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]+=value;

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// += operator for second matrix B                                       // 
//    svt_matrix::operator+= (const svt_matrix<T>& B)                    //
// adds matix B to this matrix, throws svt_exception if dimensions       //
// are not conform                                                       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator+=(const svt_matrix<T>& B) 
{

  if (m_iWidth != B.m_iWidth || m_iHeight != B.m_iHeight )
	throw svt_exception("svt_matrix:: matrix addition of 2 matrixes of non-conform size!");

  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]+=B.m_pData[i];

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// prefix -- operator: performs -- on each element                       //
//    svt_matrix::operator--                                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator--() 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	--m_pData[i];

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// postix -- operator: performs -- on each element                       //
//    svt_matrix::operator--                                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator--(int) 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]--;

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// -= operator for scalar values                                         // 
//    svt_matrix::operator-= (const T& value)                            //
// substracts value from each matrix element                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator-=(const T& value) 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]-= value;

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// -= operator for second matrix B                                       // 
//    svt_matrix::operator-= (const svt_matrix<T>& B)                    //
// substracts matix B from this matrix, throws svt_exception if          //
// dimensions are not conform                                            //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator-=(const svt_matrix<T>& B) 
{

  if (m_iWidth != B.m_iWidth || m_iHeight != B.m_iHeight )
	throw svt_exception("svt_matrix:: matrix subtraction of 2 matrixes of non-conform size!");

  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]-=B.m_pData[i];

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// *= operator for scalar values (scalar multiplication)                 // 
//    svt_matrix::operator*= (const T& value)                            //
// multiplicates each matrix element with value                          //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator*=(const T& value) 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i]*= value;

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// *= operator for a second matrix B (matrix multiplication)             // 
//    svt_matrix::operator*= (const svt_matrix<T>& B)                    //
// performs matrix multiplacation this * B                               //
// note the the dimension of this usually changes:                       //
//    this(h1,b1) * B(h2,b2) -> this(h1,b2)    if b1==h2                 //
//    throws svt_exception                     otherwise                 //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator*=(const svt_matrix<T>& B) 
{
  // 
  // use *(matrix, matrix)-operator
  //
  *this=(*this)*B;
  return *this;
}


///////////////////////////////////////////////////////////////////////////
// /= operator for scalar value                                          // 
//    svt_matrix::operator/= (const T& B)                                //
// same as this *= (1/value)                                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T>& svt_matrix<T>::operator/=(const T& value) 
{
  for (unsigned i=0; i<m_iHeight*m_iWidth; i++)
	m_pData[i] /= value;

  return *this;
}


///////////////////////////////////////////////////////////////////////////
// query amount of columns                                               // 
//    svt_matrix::width() const                                          //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline unsigned svt_matrix<T>::width() const
{
  return m_iWidth;
}


///////////////////////////////////////////////////////////////////////////
// query amount of rows                                                  // 
//    svt_matrix::height() const                                         //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline unsigned svt_matrix<T>::height() const
{
  return m_iHeight;
}


///////////////////////////////////////////////////////////////////////////
// change dimensions                                                     // 
//    svt_matrix::resize( unsigned iHeight, unsigned iWidth,             // 
//                        bool bSaveData, const T& tInitialValue )       //
// change dimensions to new height and width                             //
// if sizes are same as old sizes, nothing happens                       //
// if bSaveData is true (default), old content will be resotred          //
// new elements (or all elements, if bSaveData is set to false)          //
// will become iInitialValue                                             //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline void svt_matrix<T>::resize( unsigned iHeight, unsigned iWidth, 
								   ResizeMode eResizeMode, const T& tFillValue )
{

  //
  // nothing to to if we are already in desired shape
  //
  if ( (iWidth == m_iWidth) && (iHeight == m_iHeight) )
	return;


  //
  // is static memory is used, we cannot resize it
  // -> throw exception
  //
  if (!m_bUsesDynMem)
	throw svt_exception("svt_matrix:: attempting to resize a fixed-size matrix!");

  if ( iWidth == 0 || iHeight == 0)
	{
	m_iWidth  = 0;
	m_iHeight = 0;
	
	if (m_pData)
	  delete [] m_pData;
	m_pData = NULL;
	return;
	}


  if ( (m_iWidth*m_iHeight == iWidth*iHeight) && (eResizeMode==Uninitialized))
	return;

  T* data_tmp = new T [iWidth*iHeight];

  if (!m_pData) eResizeMode=Uninitialized;

  switch (eResizeMode) {
	int i,j, iRef, jRef, iRef2, jRef2;
	int off_i, off_j;
	double rel_x, rel_y;

    case Clear: 
	  for (i=0;i<int(iWidth*iHeight);i++) data_tmp[i]=tFillValue; break;

    case Save: 
	  for (i=0; i<int(iHeight); i++)
		for (j=0; j<int(iWidth); j++)
		  data_tmp[i*iWidth+j] = 
			(i < int(m_iHeight)&& j < int(m_iWidth)) ? 
			m_pData[i*m_iWidth+j] : tFillValue;
	  break;

  case SaveClamp:
	  for (i=0; i<int(iHeight); i++)
		{
		iRef = (i >= int(m_iHeight)) ? m_iHeight-1 : i; 
		for (j=0; j<int(iWidth); j++)
		  {
		  jRef = (j >= int(m_iWidth) ) ? m_iWidth-1 : j; 
		  data_tmp[i*iWidth+j] = m_pData[iRef*m_iWidth+jRef];
		  }
		}
	  break;

  case SaveCenter:
	off_i = (int(iHeight)-int(m_iHeight))/2;
	off_j = (int(iWidth)-int(m_iWidth))/2;

	for (iRef=-off_i, i=0; i<int(iHeight); iRef++, i++)
	  for (jRef=-off_j, j=0; j<int(iWidth); jRef++, j++)
		data_tmp[i*iWidth+j] = 
		  ( iRef >= 0 && iRef < int(m_iHeight) &&
			jRef >= 0 && jRef < int(m_iWidth) ) ? 
		  m_pData[iRef*m_iWidth+jRef] : tFillValue; 
	break;

  case SaveCenterClamp:
	off_i = (int(iHeight)-int(m_iHeight))/2;
	off_j = (int(iWidth)-int(m_iWidth))/2;

	for (iRef=-off_i, i=0; i<int(iHeight); iRef++, i++)
	  {
		if (iRef<0) iRef2=0;
		else if (iRef>=int(m_iHeight)) iRef2=m_iHeight-1;
		else iRef2=iRef;

		for (jRef=-off_j, j=0; j<int(iWidth); jRef++, j++)
		  {
			if (jRef<0) jRef2=0;
			else if (jRef>=int(m_iWidth)) jRef2=m_iWidth-1;
			else jRef2=jRef;
			data_tmp[i*iWidth+j] = m_pData[iRef2*m_iWidth+jRef2];
		  }
	  }
	break;

  case Interpolate:

	rel_x = (iWidth>1)  ? double(m_iWidth-1)/double(iWidth-1) : double(m_iWidth-1)/2;
	rel_y = (iHeight>1) ? double(m_iHeight-1)/double(iHeight-1): double(m_iHeight-1)/2;

	for(i=0;i<int(iHeight);i++) 
	  {
	  double doy=  (iHeight>1) ? i*rel_y : rel_y;
	  iRef = (int) (doy+DBL_EPSILON);    
	  doy= doy-iRef;
	  iRef2 = (iRef==int(m_iHeight-1)) ? iRef : iRef+1; 
	  for(j=0;j<int(iWidth);j++) 
		{
		double dox=  (iWidth>1) ?  j*rel_x : rel_x;
		jRef=(int) (dox+DBL_EPSILON);      
		dox=dox-jRef;
		jRef2 = (jRef==int(m_iWidth-1)) ? jRef : jRef+1; 
		double val =  (1.0-doy) *(1.0-dox)* m_pData[iRef*m_iWidth +jRef ];
		val+=         (1.0-doy) *(dox)    * m_pData[iRef *m_iWidth+jRef2];
		val+=         (doy)     *(1.0-dox)* m_pData[iRef2*m_iWidth+jRef ];
		val+=         (doy)     *(dox)    * m_pData[iRef2*m_iWidth+jRef2];
        data_tmp[i*iWidth + j]= T(val); 
		}
	  }

	break;

  default: break;
  }

  if (m_pData)
	delete [] m_pData;

  m_pData = data_tmp;
  m_iWidth = iWidth;
  m_iHeight = iHeight;
}

///////////////////////////////////////////////////////////////////////////
// stream out matrix content (used by << operator)                       // 
//    svt_matrix::streamOut(ostream& s) const                            // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline void svt_matrix<T>::streamOutA(ostream& s) const
{
    // output in matlab/octave format

    s << "# type: matrix" << endl;
    s << "# rows: " << m_iHeight << endl;
    s << "# columns: " << m_iWidth << endl;

    for (unsigned iRow=0;iRow<m_iHeight; iRow++)
    {
	for (unsigned iCol=0;iCol<m_iWidth; iCol++)
	    s << m_pData[iRow*m_iWidth+iCol] << "  ";
	s << endl;
    }

  return;

}


template <class T>
inline void svt_matrix<T>::streamOutB(svt_obfstream& s) const
{

  s << m_iHeight << m_iWidth;

  if (s.swapping())
	{
	for (unsigned i=0; i<m_iWidth*m_iHeight;i++ )
	  s << m_pData[i];
	}
  else
	s.write((char*) m_pData, m_iWidth*m_iHeight*sizeof(T)  );

  return;

}


///////////////////////////////////////////////////////////////////////////
// stream in matrix content (used by >> operator)                        // 
//    svt_matrix::streamIn (istream& s)                                  // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline void svt_matrix<T>::streamInA (istream& s)
{
  unsigned iHeight, iWidth;
  char c;
  s >> iHeight >> c >> iWidth;
  resize(iHeight, iWidth);
  
  for (unsigned iRow=0;iRow<m_iHeight; iRow++)
	for (unsigned iCol=0;iCol<m_iWidth; iCol++)
	  s >> m_pData[iRow*m_iWidth+iCol];
  
  return;

}

template <class T>
inline void svt_matrix<T>::streamInB (svt_ibfstream& s)
{
  unsigned iHeight, iWidth;

  s >> iHeight >> iWidth;

  resize(iHeight, iWidth);

  s.read( (char*) m_pData, m_iWidth*m_iHeight*sizeof(T) );
  
  if (svt_types::BigEndian())
	{
	for (unsigned i=0;i<m_iWidth*m_iHeight;i++ )
	  m_pData[i] = svt_swap(m_pData[i]);
	}

  return;

}



template <class T>
inline T*  svt_matrix<T>::c_data() const
{ return m_pData; }


template <class T>
inline T svt_matrix<T>::min() const
{
  if (!m_pData)
	throw svt_exception("min:: matrix has no elements");
  T tMin = *m_pData;
  for (unsigned i=1; i<height()*width(); i++)
	if ( m_pData[i] < tMin )
	  tMin = m_pData[i];
  return tMin;

}

/**
 * min on the row
 */
template <class T>
inline T svt_matrix<T>::minOnRow(unsigned int iIndexRow) const
{
    if (!m_pData)
	throw svt_exception("min:: matrix has no elements");
    T tMin = m_pData[iIndexRow*width()];
    for (unsigned i=iIndexRow*width()+1; i<(1+iIndexRow)*width(); i++)
    {
	if ( m_pData[i] < tMin )
	    tMin = m_pData[i];
    }
    return tMin;

}

/**
 * max on the row
 */
template <class T>
	inline T svt_matrix<T>::maxOnRow(unsigned int iIndexRow) const
{
    if (!m_pData)
	throw svt_exception("maxOnRow:: matrix has no elements");
    T tMax = m_pData[iIndexRow*width()];
    for (unsigned i=iIndexRow*width()+1; i<(1+iIndexRow)*width(); i++)
    {
	if ( m_pData[i] > tMax )
	    tMax = m_pData[i];
    }
    return tMax;

}
/**
 * The n-th greater element on the rows (index n-1 in the ascending sorted list)
 *\param iIndexRow the index of the rows
 *\param iIndex = n
 */
template <class T>
inline T svt_matrix<T>::nthMaxOnRow(unsigned int iIndexRow, unsigned int iIndex) const
{
    if (!m_pData)
	throw svt_exception("max:: matrix has no elements");
    
    vector<T> oVec;
    
    for (unsigned int iIndexCol = iIndexRow*width(); iIndexCol < (iIndexRow + 1)*width(); iIndexCol++)
	oVec.push_back(m_pData[iIndexCol]);
    
    sort(oVec.begin(),oVec.end()); // ascending 
    
    if (oVec.size() >= iIndex)
    {
        return oVec[iIndex-1];
    }
    else
    {
	svtout << "Warning: the index out of boundaries. The max value is returned!" << endl;
	return oVec[oVec.size()-1];
    }
}

template <class T>
inline T svt_matrix<T>::max() const
{
  if (!m_pData)
	throw svt_exception("max:: matrix has no elements");
  T tMax = *m_pData;
  for (unsigned i=1; i<height()*width(); i++)
	if ( m_pData[i] > tMax )
	  tMax = m_pData[i];
  return tMax;

}

/**
 * nxn matrix inversion by Gauss-Jordan elimination
 */
template <class T>
void svt_matrix<T>::gaussjordan()
{
    unsigned int i, j, k, l, m, ic=0, ir=0;
    int q;
    int *coli, *rowi, *pivi;
    T pivinv, currmax, dummy;
    T tmp;

    // is this a nxn matrix?
    if (width() != height())
	return;

    // memory allocation
    coli = new int[m_iWidth];
    if (coli == NULL)
    {
	cout << "svt_matrix> Error: Could not satisfy memory allocation request" << endl;
	exit(52910);
    }

    rowi = new int[m_iWidth];
    if (rowi == NULL)
    {
	cout << "svt_matrix> Error: Could not satisfy memory allocation request" << endl;
	exit(52920);
    }

    pivi = new int[m_iWidth];
    if (pivi == NULL)
    {
	cout << "svt_matrix> Error: Could not satisfy memory allocation request" << endl;
	exit(52930);
    }

    for (j=0;j<m_iWidth;j++)
	pivi[j]=0;

    for (i=0;i<m_iWidth;i++)
    {
	currmax=0;
	for (j=0;j<m_iWidth;j++)
	    if (pivi[j] != 1)
		for (k=0;k<m_iWidth;k++)
		{
		    if (pivi[k] == 0)
		    {
			if (fabs((long double) (*this)[j][k]) >= currmax)
			{
			    currmax=(T)fabs((long double) (*this)[j][k]);
			    ir=j;
			    ic=k;
			}
		    } else
			if (pivi[k] > 1)
			{
			    cout << "svt_matrix> Error: Matrix singular - pivot" << endl;
			    exit(52940);
			}
		}

	++(pivi[ic]);

	if (ir != ic)
	    for (l=0;l<m_iWidth;l++)
	    {
		tmp = (*this)[ir][l];
		(*this)[ir][l] = (*this)[ic][l];
		(*this)[ic][l] = tmp;
	    }

	rowi[i]=ir;
	coli[i]=ic;
	if ((*this)[ic][ic] == 0)
	{
	    cout << "svt_matrix> Error: Matrix singular" << endl;
	    exit(52950);
	}

	pivinv=(T)(1.0)/(*this)[ic][ic];
	(*this)[ic][ic]=1;
	for (l=0;l<m_iWidth;l++)
	    (*this)[ic][l] *= pivinv;

	for (m=0;m<m_iWidth;m++)
	    if (m != ic)
	    {
		dummy=(*this)[m][ic];
		(*this)[m][ic]=0;
		for (l=0;l<m_iWidth;l++)
		    (*this)[m][l] -= (*this)[ic][l]*dummy;
	    }
    }

    for (q=m_iWidth-1;q>=0;q--)
	if (rowi[q] != coli[q])
	    for (k=0;k<m_iWidth;k++)
	    {
		tmp = (*this)[k][rowi[q]];
		(*this)[k][rowi[q]] = (*this)[k][coli[q]];
		(*this)[k][coli[q]] = tmp;
	    }

    // deallocate memory
    delete[] coli;
    delete[] rowi;
    delete[] pivi;
}

/**
 * Filles the matrix with the values of the argument matrix. It places them as a block
 * \param oSrc provides the values to copy
 * \param iRow the row position where the top right cornet of oSrc will be placed
 * \param iCol the column position where the top right cornet of oSrc will be placed
 */
 template<class T>
 void svt_matrix<T>::fill(svt_matrix<T> &oSrc, unsigned int iRow, unsigned int iCol)
{
    // error check - check range
    if (oSrc.width()+iCol > m_iWidth)
    	throw svt_exception("Fill error: the Destination matrix is too small! Insuficient columns.");
   
    if (oSrc.height() + iRow > m_iHeight )
        throw svt_exception("Fill error: the Destination matrix is too small! Insuficient rows.");
    
    
    //fill in the Dest matric the src as a bloct starting with position (iRow, iCol)
    for (unsigned int iIndexRow = 0; iIndexRow < oSrc.height(); iIndexRow++)
	for (unsigned int iIndexCol = 0; iIndexCol < oSrc.width();iIndexCol++)
	    if (m_pData[(iIndexRow+iRow)*m_iWidth+(iIndexCol+iCol)] != 0)
            {
		char pErrorMsg[80];
		sprintf(pErrorMsg,"Fill error at %d:%d the src matrix overlaps the values in Destination matrix", iRow, iCol);
		throw svt_exception(pErrorMsg);
	    }
	    else
	       m_pData[(iIndexRow+iRow)*m_iWidth+(iIndexCol+iCol)] = oSrc[iIndexRow][iIndexCol];
}


/////////////////////////////////////////////////////////////////////////////



  //////////////////////////////////////////////////////////////////////
  //                                                                  //
  //                F R I E N D   O P E R A T O R S                   //
  //                                                                  //
  //////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
// == : compare 2 matrixes                                               // 
//    bool operator== (const svt_matrix<T>& A, const svt_matrix<T>& B)   //
///////////////////////////////////////////////////////////////////////////


template <class T>
inline bool operator== (const svt_matrix<T>& A, const svt_matrix<T>& B)
{
  if (&A == &B)
	return true;

  if ( A.width() != B.width()  ||  A.height() != B.height() )
	return false;

  for ( unsigned i=0; i<A.width()*A.height(); i++ )
	if ( A.c_data()[i] != B.c_data()[i])
	  return false;


  return true;
}


///////////////////////////////////////////////////////////////////////////
// != : compare 2 matrixes                       (same as !(A==B)        // 
//    bool operator== (const svt_matrix<T>& A, const svt_matrix<T>& B)   //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline bool operator!= (const svt_matrix<T>& A, const svt_matrix<T>& B)
{
  return !(A==B);
}


///////////////////////////////////////////////////////////////////////////
// + : add 2 matrixes                                                    // 
//   svt_matrix operator+ (const svt_matrix<T>& A,                       // 
//                         const svt_matrix<T>& B )                      // 
// throws svt_exception if dimesions are not conform                     //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator+ (const svt_matrix<T>& A, const svt_matrix<T>& B)
{
  svt_matrix<T> C(A);
  C+=B;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// + : add matrix and scalar -> matrix                                   // 
//   svt_matrix operator+ (const svt_matrix<T>& A, const T& value)       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator+ (const svt_matrix<T>& A, const T& value)
{
  svt_matrix<T> C(A);
  C += value;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// + : add scalar and matrix -> matrix                                   // 
//   svt_matrix operator+ (const T& value, const svt_matrix<T>& A)       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator+ (const T& value, const svt_matrix<T>& A)
{
  return A + value;
}


///////////////////////////////////////////////////////////////////////////
// - : substract 2 matrixes                                              // 
//   svt_matrix operator- (const svt_matrix<T>& A,                       // 
//                         const svt_matrix<T>& B )                      // 
// throws svt_exception if dimesions are not conform                     //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator- (const svt_matrix<T>& A, const svt_matrix<T>& B)
{
  svt_matrix<T> C(A);
  C-=B;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// - : substract scalar from matrix -> matrix                            // 
//   svt_matrix operator- (const svt_matrix<T>& A, const T& value)       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator- (const svt_matrix<T>& A, const T& value)
{
  svt_matrix<T> C(A);
  C -= value;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// - : substract matrix from scalar                ( same as -(A-value) )// 
//   svt_matrix operator+ (const T& value, const svt_matrix<T>& A)       //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator- (const T& value, const svt_matrix<T>& A)
{
  return -(A-value);
}


///////////////////////////////////////////////////////////////////////////
// - : negate each matrix element                                        // 
//   svt_matrix operator- (const svt_matrix<T>& A)                       // 
// throws svt_exception if dimesions are not conform                     //
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator- (const svt_matrix<T>& A)
{

  svt_matrix<T> C(A.height(), A.width());

  for (unsigned i=0; i<C.height()*C.width(); i++)
	C.c_data()[i] = -A.c_data()[i];

  return C;
}



///////////////////////////////////////////////////////////////////////////
// * : multiplication of 2 matrices                                      // 
//   svt_matrix operator* (const svt_matrix<T>& A,                       // 
//                         const svt_matrix<T>& B )                      // 
// performs matrix multiplacation A(h1,b1) * B(h2,b2) -> matrix(h1,b2)   //
// throws svt_exception if b1 != h2                                      //
///////////////////////////////////////////////////////////////////////////

template <class T>
inline svt_matrix<T>& mat_mult
(const svt_matrix<T>& A, const svt_matrix<T>& B, svt_matrix<T>& C)
{
  
  T sum;

  //
  // loop over each element of the new matrix
  //
  for (unsigned iRow=0; iRow<C.height(); iRow++)
	for (unsigned iCol=0; iCol<C.width(); iCol++)
	  // compute each element as product of A(iRow,*) * B(*,iCol)
	  {
	  sum = 0;
	  for (unsigned i=0; i<A.width(); i++)
		sum += A[iRow][i] * B[i][iCol];
	  C[iRow][iCol] = sum;
	  }

  return C;
}

template <class T>
inline svt_matrix<T> operator*(const svt_matrix<T>& A, const svt_matrix<T>& B) 
{
  if ( A.width() != B.height() )
	throw svt_exception("matrix multiplication of 2 matrixes of non-conform size!");
 
  svt_matrix<T> C(A.height(), B.width());
  return mat_mult(A,B,C);
}


///////////////////////////////////////////////////////////////////////////
// * : matrix scalar multiplication                                      // 
//   svt_matrix operator* (const svt_matrix<T>& A, const T& value        // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator*(const svt_matrix<T>& A, const T& value) 
{
  svt_matrix<T> C(A);
  C*=value;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// * : matrix scalar multiplication                                      // 
//   svt_matrix operator* (const T& value, const svt_matrix<T>& A        // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator*(const T& value, const svt_matrix<T>& A) 
{
  svt_matrix<T> C(A);
  C*=value;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// / : same as A * (1/value)                                             // 
//   svt_matrix operator/ (const svt_matrix<T>& A, const T& value        // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline svt_matrix<T> operator/ (const svt_matrix<T>& A, const T& value) 
{
  svt_matrix<T> C(A);
  C/=value;
  return C;
}


///////////////////////////////////////////////////////////////////////////
// get the maximum value of A                                            // 
//   const T& max(const svt_matrix<T>& A)                                // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline T max(const svt_matrix<T>& A)
{
  if (!A.c_data())
	throw svt_exception("max:: matrix has no elements");

  T tMax = A[0][0];

  for (unsigned i=1; i<A.height() * A.width(); i++)
	if ( A.c_data()[i] > tMax )
	  tMax = A.c_data()[i];
	  
  return tMax;

}


///////////////////////////////////////////////////////////////////////////
// get the minimum value of A                                            // 
//   const T& min(const svt_matrix<T>& A)                                // 
///////////////////////////////////////////////////////////////////////////
template <class T>
inline T min(const svt_matrix<T>& A) 
{
  if (!A.c_data())
	throw svt_exception("min:: matrix has no elements");

  T tMin = A[0][0];

  for (unsigned i=1; i<A.height() * A.width(); i++)
	if ( A.c_data()[i] < tMin )
	  tMin = A.c_data()[i];
  
  return tMin;

}



#endif

